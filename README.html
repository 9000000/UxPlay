<h1 id="uxplay-1.52-airplayairplay-mirror-server-for-linux-macos-and-unix.">UxPlay 1.52: AirPlay/AirPlay-Mirror server for Linux, macOS, and Unix.</h1>
<h3 id="now-developed-at-the-github-site-httpsgithub.comfdh2uxplay-where-all-user-issues-should-be-posted.">Now developed at the GitHub site <a href="https://github.com/FDH2/UxPlay">https://github.com/FDH2/UxPlay</a> (where all user issues should be posted).</h3>
<p>Highlights:</p>
<ul>
<li>GPLv3, open source.</li>
<li>Support for both AirPlay Mirror and AirPlay Audio-only (Apple Lossless ALAC) streaming protocols from current iOS/iPadOS 15.4 clients.</li>
<li>macOS computers (2011 or later, both Intel and “Apple Silicon” M1 systems) can act either as AirPlay clients, or as the server running UxPlay. Using AirPlay, UxPlay can emulate a second display for macOS clients.</li>
<li>Support for older iOS clients (such as 32-bit iPad 2nd gen. and iPhone 4S, when upgraded to iOS 9.3.5 or later), and a Windows AirPlay-client emulator, AirMyPC.</li>
<li>Uses GStreamer, with options to select different output “videosinks” and “audiosinks”, and fully-configurable video streaming pipeline.</li>
<li>Support for server behind a firewall.</li>
<li><strong>New</strong>: Support for Raspberry Pi, with hardware video acceleration by Video4Linux2 (replacement for 32-bit-only OpenMAX, which is no longer supported by Raspberry Pi OS). (For GStreamer &lt; 1.22, a <a href="https://github.com/FDH2/UxPlay/wiki/Gstreamer-Video4Linux2-plugin-patches">patch</a> to the GStreamer Video4Linux2 plugin, available in the <a href="https://github.com/FDH2/UxPlay/wiki">UxPlay Wiki</a>, is required, unless your distribution has made a backport of changes from the development version.) See <a href="https://github.com/FDH2/UxPlay/wiki/UxPlay-on-Raspberry-Pi:-success-reports:">success reports</a>.</li>
</ul>
<p>This project is a GPLv3 open source unix AirPlay2 Mirror server for Linux, macOS, and *BSD. It was initially developed by <a href="http://github.com/antimof/Uxplay">antimof</a> using code from <a href="https://github.com/FD-/RPiPlay">RPiPlay</a>, which in turn derives from <a href="https://github.com/KqsMea8/AirplayServer">AirplayServer</a>, <a href="https://github.com/juhovh/shairplay">shairplay</a>, and <a href="https://github.com/EstebanKubata/playfair">playfair</a>. (The antimof site is no longer involved in development, but periodically posts updates pulled from the new main <a href="https://github.com/FDH2/UxPlay">UxPlay site</a>).</p>
<p>UxPlay is tested on a number of systems, including (among others) Debian 10.11 “Buster” and 11.2 “Bullseye”, Ubuntu 20.04 and 22.04, Linux Mint 20.3, Pop!_OS 21.10 (NVIDIA edition), Rocky Linux 8.5 (a CentOS successor), OpenSUSE 15.3, Arch Linux 5.16.8, macOS 12.3 (Intel and M1), FreeBSD 13.0.</p>
<p>Its main use is to act like an AppleTV for screen-mirroring (with audio) of iOS/iPadOS/macOS clients (iPhones, iPads, MacBooks) in a window on the server display (with the possibility of sharing that window on screen-sharing applications such as Zoom) on a host running Linux, macOS, or other unix. UxPlay supports a “legacy” form of Apple’s AirPlay Mirror protocol introduced in iOS 12; client devices running iOS/iPadOS 9.3.5 or later are supported, as is a (non-free) Windows-based AirPlay-client software emulator, AirMyPC. (Details of what is publically known about Apple’s AirPlay2 protocol can be found <a href="https://github.com/SteeBono/airplayreceiver/wiki/AirPlay2-Protocol">here</a> and <a href="https://emanuelecozzi.net/docs/airplay2">here</a>).</p>
<p>The UxPlay server and its client must be on the same local area network, on which a <strong>Bonjour/Zeroconf mDNS/DNS-SD server</strong> is also running (only DNS-SD “Service Discovery” service is strictly necessary, it is not necessary that the local network also be of the “.local” mDNS-based type). On Linux and BSD Unix servers, this is usually provided by <a href="https://www.avahi.org">Avahi</a>, through the avahi-daemon service, and is included in most Linux distributions (this service can also be provided by macOS, iOS or Windows servers).</p>
<p>Connections to the UxPlay server by iOS/MacOS clients can be initiated both in AirPlay Mirror mode (which streams lossily-compressed AAC audio while mirroring the client screen, or in the alternative AirPlay Audio mode which streams Apple Lossless (ALAC) audio without screen mirroring (the accompanying cover art in this mode is not displayed, but metadata is displayed in the terminal). <em>Switching between these two modes during an active connection is possible: in Mirror mode, close the mirror window and start an Audio mode connection, switch back by initiating a Mirror mode connection.</em></p>
<ul>
<li><strong>Note that Apple DRM (as found in Apple TV app content on the client) cannot be decrypted by UxPlay, and (unlike a true AppleTV), the UxPlay server does not allow the Apple client to run a http connection on the server that directly streams content from the internet to the server, instead of streaming it to the client, and then re-streaming to the server.</strong></li>
</ul>
<h3 id="possibility-for-using-hardware-accelerated-h264-video-decoding-if-available.">Possibility for using hardware-accelerated h264 video-decoding, if available.</h3>
<p>UxPlay uses <a href="https://gstreamer.freedesktop.org">GStreamer</a> Plugins for rendering audio and video, This means that video and audio are supported “out of the box”, using a choice of plugins. AirPlay streams video in h264 format: gstreamer decoding is plugin agnostic, and uses accelerated GPU hardware h264 decoders if available; if not, software decoding is used.</p>
<p>For systems with Intel or AMD integrated graphics, hardware GPU decoding with the gstreamer VAAPI plugin is preferable. VAAPI is open-source, and in addition to Intel and AMD graphics, the open-source “Nouveau” drivers for NVIDIA graphics are also in principle supported: see <a href="https://nouveau.freedesktop.org/VideoAcceleration.html">here</a>, which requires VAAPI to be supplemented with firmware extracted from the proprietary NVIDIA drivers.</p>
<p>For NVIDIA graphics with the proprietary drivers, the <code>nvh264dec</code> plugin (included in gstreamer1.0-plugins-bad since GStreamer-1.18.0) can be used for accelerated video decoding on the NVIDIA GPU after NVIDIA’s CUDA driver <code>libcuda.so</code> is installed. This plugin should be used with options <code>uxplay -vd nvh264dec -vs glimagesink</code>. For GStreamer-1.16.3 or earlier, the plugin is called <code>nvdec</code>, and must be built by the user: see <a href="https://github.com/FDH2/UxPlay/wiki/NVIDIA-nvdec-and-nvenc-plugins">these instructions</a>. This older form of the NVIDIA plugin should be used with the <code>-vd nvdec -vs glimagesink</code> uxplay options.</p>
<ul>
<li><p><strong>GPU Support for Raspberry Pi</strong></p>
<p>Raspberry Pi (RPi) computers can run UxPlay with software decoding of h264 video (by adding <code>-avdec</code> to the uxplay options) but this usually has unacceptable latency, and hardware-accelerated decoding by the Pi’s built-in Broadcom GPU should be used. RPi OS (Bullseye) has abandoned the unmaintained 32-bit-only omx (OpenMAX) driver used for this by <a href="http://github.com/FD-/RPiPlay">RPiPlay</a>, in favor of v4l2 (Video4Linux2). Fixes to the GStreamer v4l2 plugin that allow it to work with UxPlay on RPi are now in the GStreamer-1.21 development branch, and will only be available in the upcoming GStreamer-1.22 release, but a (partial) backport (as <code>gstreamer1.0-plugins-good-1.18.4-2+~rpt1</code>) for RPi OS (Bullseye) has already appeared in its current updates. Until the promised full update appears, or if you are using a different distribution,you can find <a href="https://github.com/FDH2/UxPlay/wiki/Gstreamer-Video4Linux2-plugin-patches">patching instructions for GStreamer</a> in the <a href="https://github.com/FDH2/UxPlay/wiki">UxPlay Wiki</a>. Patches for GStreamer-1.18.5 (for Ubuntu 21.10), 1.18.6, 1.20.0, 1.20.1 (for Ubuntu 22.04) and 1.20.2 (for Manjaro RPi 4 22.04) are also available.</p></li>
</ul>
<h3 id="note-to-packagers-openssl-3.0.0-solves-gpl-v3-license-issues.">Note to packagers: OpenSSL-3.0.0 solves GPL v3 license issues.</h3>
<p>Some Linux distributions such as Debian do not allow distribution of compiled GPL code linked to OpenSSL-1.1.1 because its “dual OpenSSL/SSLeay” license has some incompatibilities with GPL, unless all code authors have explicitly given an “exception” to allow such linking (the historical origins of UxPlay make this impossible to obtain). Other distributions treat OpenSSL as a “System Library” which the GPL allows linking to.</p>
<p>For “GPL-strict” distributions, UxPlay can be built using OpenSSL- 3.0.0, which has anew <a href="https://www.openssl.org/blog/blog/2021/09/07/OpenSSL3.Final/">GPLv3-compatible license</a>.</p>
<h1 id="getting-uxplay">Getting UxPlay:</h1>
<p>Either download and unzip <a href="https://github.com/FDH2/UxPlay/archive/refs/heads/master.zip">UxPlay-master.zip</a>, or (if git is installed): “git clone https://github.com/FDH2/UxPlay”. You can also download a recent or earlier version listed in <a href="https://github.com/FDH2/UxPlay/releases">Releases</a>.</p>
<p>*Current UxPlay is also a pull request on the original site https://github.com/antimof/UxPlay ; that original project is inactive, but the pull requests are now being periodically merged with the antimof tree (thank you antimof!).</p>
<h2 id="building-uxplay-on-linux-or-bsd">Building UxPlay on Linux (or *BSD):</h2>
<p>(Instructions for Debian/Ubuntu; adapt these for other Linuxes; for macOS, see below). See <a href="#troubleshooting">Troubleshooting</a> below for help with any difficulties.</p>
<p>You need a C/C++ compiler (e.g. g++) with the standard development libraries installed. Debian-based systems provide a package “build-essential” for use in compiling software. You also need pkg-config: if it is not found by “<code>which pkg-config</code>”, install pkg-config or its work-alike replacement pkgconf. Also make sure that cmake&gt;=3.4.1 is installed: “<code>sudo apt-get install cmake</code>” (add <code>build-essential</code> and <code>pkg-config</code> (or <code>pkgconf</code>) to this if needed).</p>
<p>Make sure that your distribution provides OpenSSL 1.1.1 or later, and libplist 2.0 or later. (This means Debian 10 “Buster”, Ubuntu 18.04 or later.) If it does not, you may need to build and install these from source (see below).</p>
<p>In a terminal window, change directories to the source directory of the downloaded source code (“UxPlay-*”, “*” = “master” or the release tag for zipfile downloads, “UxPlay” for “git clone” downloads), then follow the instructions below:</p>
<p><strong>Note:</strong> By default UxPlay will be built with optimization for the computer it is built on; when this is not the case, as when you are packaging for a distribution, use the cmake option <code>-DNO_MARCH_NATIVE=ON</code>.</p>
<ol type="1">
<li><code>sudo apt-get install libssl-dev libplist-dev</code> (unless you need to build OpenSSL and libplist from source).</li>
<li><code>sudo apt-get install libavahi-compat-libdnssd-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev</code>.</li>
<li><code>sudo apt-get install libx11-dev</code> (only needed if you invoke the “ZOOMFIX” X11 display-name fix in the next step)</li>
<li><code>cmake .</code> (or “<code>cmake -DZOOMFIX=ON .</code>” to get a screen-sharing fix to make X11 mirror display windows visible to screen-sharing applications such as Zoom, see <a href="#improvements">Improvements</a> #3 below). <strong>ZOOMFIX is only needed for GStreamer-1.18.x or earlier</strong>.</li>
<li><code>make</code></li>
<li><code>sudo make install</code> (you can afterwards uninstall with <code>sudo make uninstall</code> in the same directory in which this was run)</li>
<li>Install GStreamer plugins that you need: <code>sudo apt-get install gstreamer1.0-&lt;plugin&gt;</code>; values of <code>&lt;plugin&gt;</code> needed are: “<strong>plugins-base</strong>”, “<strong>libav</strong>” (for sound), “<strong>plugins-good</strong>” (for v4l2 hardware h264 decoding) and “<strong>plugins-bad</strong>” (for h264 decoding). Also needed may be “<strong>gl</strong>” for OpenGL support (which may be useful, and should be used with h264 decoding by the NVIDIA GPU), and “<strong>x</strong>” for X11 support, although these may already be installed; “<strong>vaapi</strong>” is needed for hardware-accelerated h264 video decoding by Intel or AMD graphics (but not for use with NVIDIA using proprietary drivers). Also install “<strong>tools</strong>” to get the utility gst-inspect-1.0 for examining the GStreamer installation.</li>
</ol>
<p><em>If you intend to modify the code, use a separate “build” directory: replace</em> “<code>cmake  [ ] .</code>” <em>by</em> “<code>mkdir build ; cd build ; cmake [ ] ..</code>”; <em>you can then clean the build directory with</em> “<code>rm -rf build/*</code>” <em>(run from within the UxPlay source directory) without affecting the source directories which contain your modifications</em>.</p>
<p>The above script installs the executable file “<code>uxplay</code>” to <code>/usr/local/bin</code>, (and installs a manpage to somewhere like <code>/usr/local/share/man/man1</code> and README files to somewhere like <code>/usr/local/share/doc/uxplay</code>). It can also be found in the build directory after the build processs.</p>
<p><strong>Finally, run uxplay in a terminal window</strong>. If it is not seen by the iOS client’s drop-down “Screen Mirroring” panel, check that your DNS-SD server (usually avahi-daemon) is running: do this in a terminal window with <code>systemctl status avahi-daemon</code>. If this shows the avahi-daemon is not running, control it with <code>sudo systemctl [start,stop,enable,disable] avahi-daemon</code> (or avahi-daemon.service). If UxPlay is seen, but the client fails to connect when it is selected, there may be a firewall on the server that prevents UxPlay from receiving client connection requests unless some network ports are opened. See <a href="#troubleshooting">Troubleshooting</a> below for help with this or other problems.</p>
<p>One common problem involves GStreamer attempting to use incorrectly-configured or absent accelerated hardware h264 video decoding (e.g., VAAPI). Try “<code>uxplay -avdec</code>” to force software video decoding; if this works you can then try to fix accelerated hardware video decoding if you need it. See <a href="#usage">Usage</a> for more run-time options.</p>
<p><strong>Raspberry Pi</strong>: If “<code>uxplay</code>” by itself does not work, use “<code>uxplay -v4l2</code>” (or use “<code>-rpi</code>” as a synonym for “<code>-v4l2</code>”) on your desktop X11 system, and optionally specify a videosink with “<code>-vs ..</code>”; use “<code>uxplay -rpiwl</code>” as a synonym for “<code>-v4l2 -vs waylandsink</code>” on a desktop system with Wayland (this applies to Ubuntu). On a system without X11 that uses framebuffer video (such as RPi OS Bullseye “Lite”) use “<code>uxplay -rpifb</code>” as a synonym for “<code>uxplay -v4l2 -vs kmssink</code>”.</p>
<ul>
<li><p><strong>Red Hat, Fedora, CentOS (now continued as Rocky Linux or Alma Linux):</strong> (sudo yum install) openssl-devel libplist-devel avahi-compat-libdns_sd-devel (some from the “PowerTools” add-on repository) (+libX11-devel for ZOOMFIX). The required GStreamer packages (some from <a href="https://rpmfusion.org">rpmfusion.org</a>) are: gstreamer1-devel gstreamer1-plugins-base-devel gstreamer1-libav gstreamer1-plugins-bad-free (+ gstreamer1-vaapi for intel graphics).</p></li>
<li><p><strong>OpenSUSE:</strong> (sudo zypper install) libopenssl-devel libplist-devel avahi-compat-mDNSResponder-devel (+ libX11-devel for ZOOMFIX). The required GStreamer packages (you may need to use versions from <a href="https://ftp.gwdg.de/pub/linux/misc/packman/suse/">Packman</a>) are: gstreamer-devel gstreamer-plugins-base-devel gstreamer-plugins-libav gstreamer-plugins-bad (+ gstreamer-plugins-vaapi for Intel graphics).</p></li>
<li><p><strong>Arch Linux</strong> (sudo pacman -Syu) openssl libplist avahi gst-plugins-base gst-plugins-good gst-plugins-bad gst-libav (+ gstreamer-vaapi for Intel graphics). (<strong>Also available as a package in AUR</strong>).</p></li>
<li><p><strong>FreeBSD:</strong> (sudo pkg install) libplist gstreamer1, gstreamer1-libav, gstreamer1-plugins, gstreamer1-plugins-* (* = core, good, bad, x, gtk, gl, vulkan, pulse …), (+ gstreamer1-vaapi for Intel graphics). Either avahi-libdns or mDNSResponder must also be installed to provide the dns_sd library. OpenSSL is already installed as a System Library. “ZOOMFIX” is untested; don’t try to use it on FreeBSD unless you need it.</p></li>
</ul>
<h3 id="building-openssl-1.1.1-from-source.">Building OpenSSL &gt;= 1.1.1 from source.</h3>
<p>If you need to do this, note that you may be able to use a newer version (OpenSSL-3.0.1 is known to work). You will need the standard development toolset (autoconf, automake, libtool). Download the source code from <a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a>. Install the downloaded openssl by opening a terminal in your Downloads directory, and unpacking the source distribution: (“tar -xvzf openssl-3.0.1.tar.gz ; cd openssl-3.0.1”). Then build/install with “./config ; make ; sudo make install_dev”. This will typically install the needed library <code>libcrypto.*</code>, either in /usr/local/lib or /usr/local/lib64. <em>(Ignore the following for builds on MacOS:)</em> Assuming the library was placed in /usr/local/lib64, you must “export OPENSSL_ROOT_DIR=/usr/local/lib64” before running cmake. On some systems like Debian or Ubuntu, you may also need to add a missing entry <code>/usr/local/lib64</code> in /etc/ld.so.conf (or place a file containing “/usr/local/lib64/libcrypto.so” in /etc/ld.so.conf.d) and then run “sudo ldconfig”.</p>
<h3 id="bulding-libplist-2.0.0-from-source.">Bulding libplist &gt;= 2.0.0 from source.</h3>
<p><em>(Note: on Debian 9 “Stretch” or Ubuntu 16.04 LTS editions, you can avoid this step by installing libplist-dev and libplist3 from Debian 10 or Ubuntu 18.04.)</em> As well as the usual build tools (autoconf, automake, libtool), you may need to also install some libpython*-dev package. Download the latest source from <a href="https://github.com/libimobiledevice/libplist">https://github.com/libimobiledevice/libplist</a>: get <a href="https://github.com/libimobiledevice/libplist/archive/refs/heads/master.zip">libplist-master.zip</a>, then (“unzip libplist-master.zip ; cd libplist-master”), build/install (“./autogen.sh ; make ; sudo make install”). This will probably install libplist-2.0.* in /usr/local/lib. <em>(Ignore the following for builds on MacOS:)</em> On some systems like Debian or Ubuntu, you may also need to add a missing entry <code>/usr/local/lib</code> in /etc/ld.so.conf (or place a file containing “/usr/local/lib/libplist-2.0.so” in /etc/ld.so.conf.d) and then run “sudo ldconfig”.</p>
<h2 id="building-uxplay-on-macos-now-tested-on-both-intel-x86_64-and-apple-silicon-m1-macs">Building UxPlay on macOS: <strong>(Now tested on both Intel X86_64 and “Apple Silicon” M1 Macs)</strong></h2>
<p><em>Note: A native AirPlay Server feature is included in macOS 12 Monterey, but is restricted to recent hardware. UxPlay can run on older macOS systems that will not be able to run Monterey, or can run Monterey but not AirPlay.</em></p>
<p>These instructions for macOS asssume that the Xcode command-line developer tools are installed (if Xcode is installed, open the Terminal, type “sudo xcode-select –install” and accept the conditions).</p>
<p>It is also assumed that CMake &gt;= 3.13 is installed: this can be done with package managers <a href="http://www.macports.org">MacPorts</a>, <a href="http://finkproject.org">Fink</a> or <a href="http://brew.sh">Homebrew</a>, or by a download from <a href="https://cmake.org/download/">https://cmake.org/download/</a>.</p>
<p>First get the latest macOS release of GStreamer-1.0 from <a href="https://gstreamer.freedesktop.org/download/">https://gstreamer.freedesktop.org/download/</a>. Install both the macOS runtime and development installer packages. Assuming that the latest release is 1.20.2. install <code>gstreamer-1.0-1.20.2-universal.pkg</code> and <code>gstreamer-1.0-devel-1.20.2-universal.pkg</code>. (If you have an Intel-architecture Mac, and have problems with the “universal” packages, you can also use <code>gstreamer-1.0-1.18.6-x86_64.pkg</code> and <code>gstreamer-1.0-devel-1.18.6-x86_64.pkg</code>.) Click on them to install (they install to /Library/FrameWorks/GStreamer.framework). It is recommended you use GStreamer.framework rather than install Gstreamer with Homebrew or MacPorts (see later).</p>
<p>Next install OpenSSL and libplist: these can be built from source (see above), in which case you may need to install the standard development tools autoconf, automake, libtool, which can be done with MacPorts, HomeBrew, or Fink. Only the static forms of the two libraries will used for the macOS build, so you can uninstall them (“sudo make uninstall”) after you have built UxPlay. It may be easier to get them using MacPorts “sudo port install openssl libplist-devel” or Homebrew “brew install openssl libplist” (but not Fink). if you don’t have MacPorts or Homebrew installed, you can just install one of them before building uxplay, and uninstall afterwards if it is not wanted.</p>
<p>Finally, build and install uxplay (without ZOOMFIX): open a terminal and change into the UxPlay source directory (“UxPlay-master” for zipfile downloads, “UxPlay” for “git clone” downloads) and build/install with “cmake . ; make ; sudo make install” (same as for Linux).</p>
<ul>
<li><p>On macOS with this installation of GStreamer, the only videosinks available seem to be glimagesink (default choice made by autovideosink) and osxvideosink. (It seems that vaapisink is not supported on macOS). The window title does not show the Airplay server name, but the window is visible to screen-sharing apps (e.g., Zoom). The only available audiosink seems to be osxaudiosink.</p></li>
<li><p>On macOS, the option -t <em>timeout</em> is currently suppressed, and the option -nc is always used, whether or not it is selected. This is a workaround until a problem with GStreamer videosinks on macOS is fixed: if the GStreamer pipeline is destroyed while the mirror window is still open, a segfault occurs.</p></li>
<li><p>In the case of glimagesink, the resolution settings “-s wxh” do not affect the (small) initial OpenGL mirror window size, but the window can be expanded using the mouse or trackpad. In contrast, a window created with “-vs osxvideosink” is initially big, but has the wrong aspect ratio (stretched image); in this case the aspect ratio changes when the window width is changed by dragging its side.</p></li>
</ul>
<p><strong><em>Other ways (Homebrew, MacPorts) to install GStreamer on macOS (not recommended):</em></strong></p>
<p>First make sure that pkgconfig is installed (Homebrew: “brew install pkgconfig” ; MacPorts: “sudo port install pkgconfig” ).</p>
<ol type="a">
<li><p>with Homebrew: “brew install gst-plugins-base gst-plugins-good gst-plugins-bad gst-libav”. This appears to be functionally equivalent to using GStreamer.framework, but causes a large number of extra packages to be installed by Homebrew as dependencies. <strong>You may need to set the environment variable GST_PLUGIN_PATH=/usr/local/lib/gstreamer-1.0 to point to the Homebrew GStreamer installation.</strong></p></li>
<li><p>with MacPorts: “sudo port install gstreamer1-gst-plugins-base gstreamer1-gst-plugins-good gstreamer1-gst-plugins-bad gstreamer1-gst-libav”. <strong>The MacPorts GStreamer is built to use X11</strong>, so uxplay must be run from an XQuartz terminal, can use ZOOMFIX, and needs option “-vs ximagesink”. On an older unibody MacBook Pro, the default resolution wxh = 1920x1080 was too large for the non-retina display, but using option “-s 800x600” worked; However, the GStreamer pipeline is fragile against attempts to change the X11 window size, or to rotations that switch a connected client between portrait and landscape mode while uxplay is running. Using the MacPorts X11 GStreamer is only viable if the image size is left unchanged from the initial “-s wxh” setting (also use the iPad/iPhone setting that locks the screen orientation against switching between portrait and landscape mode as the device is rotated).</p></li>
</ol>
<h1 id="usage">Usage</h1>
<p>Options:</p>
<p><strong>-p</strong> allows you to select the network ports used by UxPlay (these need to be opened if the server is behind a firewall). By itself, -p sets “legacy” ports TCP 7100, 7000, 7001, UDP 6000, 6001, 7011. -p n (e.g. -p 35000) sets TCP and UDP ports n, n+1, n+2. -p n1,n2,n3 (comma-separated values) sets each port separately; -p n1,n2 sets ports n1,n2,n2+1. -p tcp n or -p udp n sets just the TCP or UDP ports. Ports must be in the range [1024-65535].</p>
<p>If the -p option is not used, the ports are chosen dynamically (randomly), which will not work if a firewall is running.</p>
<p><strong>-n server_name</strong> (Default: UxPlay); server_name@_hostname_ will be the name that appears offering AirPlay services to your iPad, iPhone etc, where <em>hostname</em> is the name of the server running uxplay. This will also now be the name shown above the mirror display (X11) window.</p>
<p><strong>-nh</strong> Do not append “<span class="citation" data-cites="_hostname_">@_hostname_</span>” at the end of the AirPlay server name.</p>
<p><strong>-s wxh</strong> (e.g. -s 1920x1080 , which is the default ) sets the display resolution (width and height, in pixels). (This may be a request made to the AirPlay client, and perhaps will not be the final resolution you get.) w and h are whole numbers with four digits or less. Note that the <strong>height</strong> pixel size is the controlling one used by the client for determining the streaming format; the width is dynamically adjusted to the shape of the image (portrait or landscape format, depending on how an iPad is held, for example).</p>
<p><strong>-s wxh@r</strong> As above, but also informs the AirPlay client about the screen refresh rate of the display. Default is r=60 (60 Hz); r must be a whole number less than 256.</p>
<p><strong>-o</strong> turns on an “overscanned” option for the display window. This reduces the image resolution by using some of the pixels requested by option -s wxh (or their default values 1920x1080) by adding an empty boundary frame of unused pixels (which would be lost in a full-screen display that overscans, and is not displayed by gstreamer). Recommendation: <strong>don’t use this option</strong> unless there is some special reason to use it.</p>
<p><strong>-fs</strong> uses fullscreen mode, but only works with Wayland or VAAPI plugins.</p>
<p><strong>-fps n</strong> sets a maximum frame rate (in frames per second) for the AirPlay client to stream video; n must be a whole number less than 256. (The client may choose to serve video at any frame rate lower than this; default is 30 fps.) A setting below 30 fps might be useful to reduce latency if you are running more than one instance of uxplay at the same time. <em>This setting is only an advisory to the client device, so setting a high value will not force a high framerate.</em> (You can test using “-vs fpsdisplaysink” to see what framerate is being received, or use the option -FPSdata which displays video-stream performance data continuously sent by the client during video-streaming.)</p>
<p><strong>-FPSdata</strong> Turns on monitoring of regular reports about video streaming performance that are sent by the client. These will be displayed in the terminal window if this option is used. The data is updated by the client at 1 second intervals.</p>
<p><strong>-m</strong> generates a random MAC address to use instead of the true hardware MAC number of the computer’s network card. (Different server_name, MAC addresses, and network ports are needed for each running uxplay if you attempt to run two instances of uxplay on the same computer.) If UxPlay fails to find the true MAC address of a network card, (more specifically, the MAC address used by the first active network interface detected) a random MAC address will be used even if option <strong>-m</strong> was not specifed. (Note that a random MAC address will be different each time UxPlay is started).</p>
<p>Also: image transforms that had been added to RPiPlay have been ported to UxPlay:</p>
<p><strong>-f {H|V|I}</strong> implements “videoflip” image transforms: H = horizontal flip (right-left flip, or mirror image); V = vertical flip ; I = 180 degree rotation or inversion (which is the combination of H with V).</p>
<p><strong>-r {R|L}</strong> 90 degree Right (clockwise) or Left (counter-clockwise) rotations; these are carried out after any <strong>-f</strong> transforms.</p>
<p><strong>-vp <em>parser</em></strong> choses the GStreamer pipeline’s h264 parser element, default is h264parse. Using quotes “…” allows options to be added.</p>
<p><strong>-vd <em>decoder</em></strong> chooses the GStreamer pipeline’s h264 decoder element, instead of letting decodebin pick it for you. Software decoding is done by avdec_h264; various hardware decoders include: vaapi264dec, nvdec, nvh264dec, v4l2h264dec (these require that the appropriate hardware is available). Using quotes “…” allows some parameters to be included with the decoder name.</p>
<p><strong>-vc <em>converter</em></strong> chooses the GStreamer pipeline’s videoconverter element, instead of the default value “videoconvert”. When using Video4Linux2 hardware-decoding by a GPU,<code>-vc  v4l2convert</code> will also use the GPU for video conversion. Using quotes “…” allows some parameters to be included with the converter name.</p>
<p><strong>-vs <em>videosink</em></strong> chooses the GStreamer videosink, instead of letting autovideosink pick it for you. Some videosink choices are: ximagesink, xvimagesink, vaapisink (for intel graphics), gtksink, glimagesink, waylandsink, osximagesink (for macOS), kmssink (for systems without X11, like Raspberry Pi OS lite) or fpsdisplaysink (which shows the streaming framerate in fps). Using quotes “…” allows some parameters to be included with the videosink name. For example, <strong>fullscreen</strong> mode is supported by the vaapisink plugin, and is obtained using <code>-vs "vaapisink fullscreen=true"</code>; this also works with <code>waylandsink</code>. The syntax of such options is specific to a given plugin, and some choices of videosink might not work on your system.</p>
<p><strong>-vs 0</strong> suppresses display of streamed video, but plays streamed audio. (The client’s screen is still mirrored at a reduced rate of 1 frame per second, but is not rendered or displayed.) This feature (which streams audio in AAC audio format) is now probably unneeded, as UxPlay can now stream superior-quality Apple Lossless audio without video in Airplay non-mirror mode.</p>
<p><strong>-v4l2</strong> Video settings for hardware h264 video decoding in the GPU by Video4Linux2.</p>
<p><strong>-rpi</strong> Equivalent to “-v4l2”. Use for “Desktop” Raspberry Pi systems with X11.</p>
<p><strong>-rpifb</strong> Equivalent to “-v4l2 -vs kmssink” (use for Raspberry Pi systems using the framebuffer, like RPi OS Bullseye Lite).</p>
<p><strong>-rpiwl</strong> Equivalent to “-v4l2 -vs waylandsink”, for Raspberry Pi “Desktop” systems using the Wayland video compositor (use for Ubuntu 21.10 for Raspberry Pi 4B).</p>
<p><strong>-avdec</strong> forces use of software h264 decoding using Gstreamer element avdec_h264 (libav h264 decoder). This option should prevent autovideosink choosing a hardware-accelerated videosink plugin such as vaapisink.</p>
<p><strong>-as <em>audiosink</em></strong> chooses the GStreamer audiosink, instead of letting autoaudiosink pick it for you. Some audiosink choices are: pulsesink, alsasink, osssink, oss4sink, and osxaudiosink (for macOS). Using quotes “…” might allow some parameters to be included with the audiosink name. (Some choices of audiosink might not work on your system.)</p>
<p><strong>-as 0</strong> (or just <strong>-a</strong>) suppresses playing of streamed audio, but displays streamed video.</p>
<p><strong>-reset n</strong> sets a limit of n consective timeout failures of the client to respond to ntp requests from the server (these are sent every 3 seconds to check if the client is still present). After n failures, the client will be presumed to be offline, and the connection will be reset to allow a new connection. The default value of n is 5; the value n = 0 means “no limit” on timeouts.</p>
<p><strong>-nc</strong> maintains previous UxPlay &lt; 1.45 behavior that does <strong>not close</strong> the video window when the the client sends the “Stop Mirroring” signal. <em>This option is currently used by default in macOS, as the window created in macOS by GStreamer does not terminate correctly (it causes a segfault) if it is still open when the GStreamer pipeline is closed.</em></p>
<p><strong>-t <em>timeout</em></strong> will cause the server to relaunch (without stopping uxplay) if no connections have been present during the previous <em>timeout</em> seconds. You may wish to use this if the Server is not visible to new Clients that were inactive when the Server was launched, and an idle Bonjour registration eventually becomes unavailable for new connections (this is a workaround for what may be due to a problem with your DNS-SD or Avahi setup). <em>This option is currently disabled in macOS, for the same reason that requires the -nc option.</em></p>
<p><strong>-vdmp</strong> Dumps h264 video to file videodump.h264. -vdmp n dumps not more than n NAL units to videodump.x.h264; x= 1,2,… increases each time a SPS/PPS NAL unit arrives. To change the name <em>videodump</em>, use -vdmp [n] <em>filename</em>.</p>
<p><strong>-admp</strong> Dumps audio to file audiodump.x.aac (AAC-ELD format audio), audiodump.x.alac (ALAC format audio) or audiodump.x.aud (other-format audio), where x = 1,2,3… increases each time the audio format changes. -admp <em>n</em> restricts the number of packets dumped to a file to <em>n</em> or less. To change the name <em>audiodump</em>, use -admp [n] <em>filename</em>.</p>
<p><strong>-d</strong> Enable debug output. Note: this does not show GStreamer error or debug messages. To see GStreamer error and warning messages, set the environment variable GST_DEBUG with “export GST_DEBUG=2” before running uxplay. To see GStreamer debug messages, set GST_DEBUG=4; increase this to see even more of the GStreamer inner workings.</p>
<h1 id="troubleshooting">Troubleshooting</h1>
<p>Note: <code>uxplay</code> is run from a terminal command line, and informational messages are written to the terminal.</p>
<h3 id="problems-in-compiling-uxplay.">0. Problems in compiling UxPlay.</h3>
<p>One user (on Ubuntu) found compilation failed with messages about linking to “usr/local/lib/libcrypto.a” and “zlib”. This was because (in addition to the standard ubuntu installation of libssl-dev), the user was unaware that a second installation with libcrypto in /usr/local was present. Solution: when more than one installation of OpenSSL is present, set the environment variable OPEN_SSL_ROOT_DIR to point to the correct one; on 64-bit Ubuntu, this is done by running <code>export OPENSSL_ROOT_DIR=/usr/lib/X86_64-linux-gnu/</code> before running cmake.</p>
<h3 id="uxplay-starts-but-stalls-after-initialized-server-sockets-appears-without-any-server-name-showing-on-the-client.">1. uxplay starts, but stalls after “Initialized server socket(s)” appears, <em>without any server name showing on the client</em>.</h3>
<p>Stalling this way, with <em>no</em> server name showing <em>on the client</em> as available, probably means that your network <strong>does not have a running Bonjour/zeroconf DNS-SD server.</strong> On Linux, make sure Avahi is installed, and start the avahi-daemon service on the system running uxplay (your distribution will document how to do this). Some systems may instead use the mdnsd daemon as an alternative to provide DNS-SD service. <em>(FreeBSD offers both alternatives, but only Avahi was tested: one of the steps needed for getting Avahi running on a FreeBSD system is to edit <code>/usr/local/etc/avahi/avahi-daemon.conf</code> to uncomment a line for airplay support.</em>)</p>
<p>After starting uxplay, use the utility <code>avahi-browse -a -t</code> in a different terminal window on the server to verify that the UxPlay AirTunes and AirPlay services are correctly registered (only the AirTunes service is used in the “Legacy” AirPlay Mirror mode used by UxPlay). If the UxPlay service is listed by avahi-browse, but is not seen by the client, the problem is likely to be a problem with the local network.</p>
<h3 id="uxplay-starts-but-stalls-after-initialized-server-sockets-appears-with-the-server-name-showing-on-the-client-but-the-client-fails-to-connect-when-the-uxplay-server-is-selected.">2. uxplay starts, but stalls after “Initialized server socket(s)” appears, <em>with the server name showing on the client</em> (but the client fails to connect when the UxPlay server is selected).</h3>
<p>This shows that a <em>DNS-SD</em> service is working, but a firewall on the server is probably blocking the connection request from the client. (One user who insisted that the firewall had been turned off turned out to have had <em>two</em> active firewalls (<em>firewalld</em> and <em>ufw</em>) <em>both</em> running on the server!) If possible, either turn off the firewall to see if that is the problem, or get three consecutive network ports, starting at port n, all three in the range 1024-65535, opened for both tcp and udp, and use “uxplay -p n” (or open UDP 6000, 6001, 6011 TCP 7000,7001,7100 and use “uxplay -p”).</p>
<h3 id="problems-after-the-client-server-connection-has-been-made">3. Problems <em>after</em> the client-server connection has been made:</h3>
<p>If you do <em>not</em> see the message <code>raop_rtp_mirror starting mirroring</code>, something went wrong before the client-server negotiations were finished. For such problems, use “uxplay -d” (debug log option) to see what is happening: it will show how far the connection process gets before the failure occurs. You can compare your debug output to that from a successful start of UxPlay in the <a href="https://github.com/FDH2/UxPlay/wiki">UxPlay Wiki</a>.</p>
<p><strong>If UxPlay reports that mirroring started, but you get no video or audio, the problem is probably from a GStreamer plugin that doesn’t work on your system</strong> (by default, GStreamer uses the “autovideosink” and “autoaudiosink” algorithms to guess what are the “best” plugins to use on your system).</p>
<p><strong>Raspberry Pi</strong> devices (-rpi option) only work with hardware GPU decoding if the Video4Linux2 plugin in GStreamer v1.20.x or earlier has been patched (see the UxPlay <a href="https://github.com/FDH2/UxPlay/wiki/Gstreamer-Video4Linux2-plugin-patches">Wiki</a> for patches). This may be fixed in the future when GStreamer-1.22 is released, or by backport patches in distributions such as Raspberry Pi OS (Bullseye).</p>
<p>Sometimes “autovideosink” may select the OpenGL renderer “glimagesink” which may not work correctly on your system. Try the options “-vs ximagesink” or “-vs xvimagesink” to see if using one of these fixes the problem.</p>
<p>Other reported problems are connected to the GStreamer VAAPI plugin (for hardware-accelerated Intel graphics, but not NVIDIA graphics). Use the option “-avdec” to force software h264 video decoding: this should prevent autovideosink from selecting the vaapisink videosink. Alternatively, find out if the gstreamer1.0-vaapi plugin is installed, and if so, uninstall it. (If this does not fix the problem, you can reinstall it.)</p>
<p>There are some reports of other GStreamer problems with hardware-accelerated Intel HD graphics. One user (on Debian) solved this with “sudo apt install intel-media-va-driver-non-free”. This is a driver for 8’th (or later) generation "*-lake" Intel chips, that seems to be related to VAAPI accelerated graphics.</p>
<p>If you <em>do</em> have Intel HD graphics, and have installed the vaapi plugin, but <code>-vs vaapisink</code> does not work, check that vaapi is not “blacklisted” in your GStreamer installation: run <code>gst-inspect-1.0 vaapi</code>, if this reports <code>0 features</code>, you need to <code>export GST_VAAPI_ALL_DRIVERS=1</code> before running uxplay, or set this in the default environment.</p>
<p>You can try to fix audio problems by using the “-as <em>audiosink</em>” option to choose the GStreamer audiosink , rather than have autoaudiosink pick one for you. The command “gst-inspect-1.0 | grep Sink | grep Audio” " will show you which audiosinks are available on your system. (Replace “Audio” by “Video” to see videosinks). Some possible audiosinks are pulsesink, alsasink, osssink, oss4sink, and osxaudiosink (macOS).</p>
<p>If you ran cmake with “-DZOOMFIX=ON”, check if the problem is still there without ZOOMFIX. ZOOMFIX is only applied to the default videosink choice (“autovideosink”) and the two X11 videosinks “ximagesink” and “xvimagesink”. ZOOMFIX is only designed for these last two; if autovideosink chooses a different videosink, ZOOMFIX is now ignored. If you are using the X11 windowing system (standard on Linux), and have trouble with screen-sharing on Zoom, use ZOOMFIX and “-vs xvimagesink” (or “-vs ximagesink” if the previous choice doesn’t work).</p>
<p>As other videosink choices are not affected by ZOOMFIX, they may or may not be visible to screen-sharing apps. Cairo-based windows created on Linux with “-vs gtksink” are visible to screen-sharing aps without ZOOMFIX; windows on macOS created by “-vs glimagesink” (default choice) and “-vs osximagesink” are also visible.</p>
<p>The “OpenGL renderer” window created on Linux by “-vs glimagesink” sometimes does not close properly when its “close” button is clicked. (this is a GStreamer issue). You may need to terminate uxplay with Ctrl-C to close a “zombie” OpenGl window. If similar problems happen when the client sends the “Stop Mirroring” signal, try the no-close option “-nc” that leaves the video window open.</p>
<h3 id="gstreamer-issues-missing-plugins-etc.">4. GStreamer issues (missing plugins, etc.):</h3>
<p>To troubleshoot GStreamer execute “export GST_DEBUG=2” to set the GStreamer debug-level environment-variable in the terminal where you will run uxplay, so that you see warning and error messages; (replace “2” by “4” to see much (much) more of what is happening inside GStreamer). Run “gst-inspect-1.0” to see which GStreamer plugins are installed on your system.</p>
<p>Some extra GStreamer packages for special plugins may need to be installed (or reinstalled: a user using a Wayland display system as an alternative to X11 reported that after reinstalling Lubuntu 18.4, UxPlay would not work until gstreamer1.0-x was installed, presumably for Wayland’s X11-compatibility mode). Different distributions may break up GStreamer 1.x into packages in different ways; the packages listed above in the build instructions should bring in other required GStreamer packages as dependencies, but will not install all possible plugins.</p>
<p>The GStreamer video pipeline, which is shown in the initial output from <code>uxplay -d</code>, has the default form</p>
<pre><code>appsrc name=video_source ! queue ! h264parse ! decodebin ! videoconvert ! autovideosink name=video_sink sync=false</code></pre>
<p>The pipeline is fully configurable: default elements “h264parse”, “decodebin”, “videoconvert”, and “autovideosink” can respectively be replaced by using uxplay options <code>-vp</code>, <code>-vd</code>, <code>-vc</code>, and <code>-vs</code>, if there is any need to modify it (entries can be given in quotes “…” to include options).</p>
<h3 id="mirror-screen-freezes">5. Mirror screen freezes:</h3>
<p>This can happen if the TCP video stream from the client stops arriving at the server, probably because of network problems (the UDP audio stream may continue to arrive). At 3-second intervals, UxPlay checks that the client is still connected by sending it a request for a NTP time signal. If a reply is not received from the client within a 0.3 sec time-window, an “ntp timeout” is registered. If a certain number (currently 5) of consecutive ntp timeouts occur, UxPlay assumes that the client is “dead”, and resets the connection, becoming available for connection to a new client, or reconnection to the previous one. Sometimes the connection may recover before the timeout limit is reached, and if the default limit is not right for your network, it can be modified using the option “-reset <em>n</em>”, where <em>n</em> is the desired timeout-limit value (<em>n</em> = 0 means “no limit”). If the connection starts to recover after ntp timeouts, a corrupt video packet from before the timeout may trigger a “connection reset by peer” error, which also causes UxPlay to reset the connection. When the connection is reset, the “frozen” mirror screen of the previous connection is left in place, and will be taken over by a new client connection when it is made.</p>
<h3 id="failure-to-decrypt-all-video-and-audio-streams-from-old-or-non-apple-clients">6. Failure to decrypt ALL video and audio streams from old or non-Apple clients:</h3>
<p>This triggers an unending stream of error messages, and means that the audio decryption key (also used in video decryption) was not correctly extracted from data sent by the client. This should not happen for iOS 9.3 or later clients. However, if a client uses the same older version of the protocol that is used by the Windows-based AirPlay client emulator <em>AirMyPC</em>, the protocol can be switched to the older version by the setting <code>OLD_PROTOCOL_CLIENT_USER_AGENT_LIST</code> in lib/global.h. UxPlay reports the client’s “User Agent” string when it connects. If some other client also fails to decrypt all audio and video, try adding its “User Agent” string in place of “xxx” in the entry “AirMyPC/2.0;xxx” in global.h and rebuild uxplay.</p>
<p>Note that Uxplay declares itself to be an AppleTV3,2 with a sourceVersion 220.68; this can also be changed in global.h. It had been thought that it was necessary for UxPlay to claim to be an older 32 bit AppleTV model that cannot run modern 64bit tvOS, in order for the client to use a “legacy” protocol for pairing with the server (see the <em>“Notes on AirPlay protocol versions”</em> at the end of this README). However, UxPlay still works if it declares itself as an AppleTV6,2 with sourceVersion 380.20.1 (an AppleTV 4K 1st gen, introduced 2017, running tvOS 12.2.1); it seems that the use of “legacy” protocol just requires bit 27 (listed as “SupportsLegacyPairing”) of the “features” plist code (reported to the client by the AirPlay server) to be set.</p>
<h1 id="changelog">ChangeLog</h1>
<p>1.52 2022-05-05 Cleaned up initial audio sync code, and reformatted streaming debug output (readable aligned timestamps with decimal points in seconds). Eliminate memory leaks (found by valgrind). Support for display of ALAC (audio-only) metadata (soundtrack artist names, titles etc.) in the uxplay terminal.</p>
<p>1.51 2022-04-24 Reworked options forVideo4Linux2 support (new option -v4l2) and short options -rpi, -rpifb, -rpiwl as synonyms for -v4l2, -v4l2 -vs kmssink, and -v4l2 -vs waylandsink. Reverted a change from 1.48 that broke reconnection after “Stop Mirroring” is sent by client.</p>
<p>1.50 2022-04-22 Added -fs fullscreen option (for Wayland or VAAPI plugins only), Changed -rpi to be for framebuffer (“lite”) RPi systems and added -rpigl (OpenGL) and -rpiwl (Wayland) options for RPi Desktop systems. Also modified timestamps from “DTS” to “PTS” for latency improvement, plus internal cleanups.</p>
<p>1.49 2022-03-28 Addded options for dumping video and/or audio to file, for debugging, etc. h264 PPS/SPS NALU’s are shown with -d. Fixed video-not-working for M1 Mac clients.</p>
<p>1.48 2022-03-11 Made the GStreamer video pipeline fully configurable, for use with hardware h264 decoding. Support for Raspberry Pi.</p>
<p>1.47 2022-02-05 Added -FPSdata option to display (in the terminal) regular reports sent by the client about video streaming performance. Internal cleanups of processing of video packets received from the client. Added -reset n option to reset the connection after n ntp timeouts (also reset after “connection reset by peer” error in video stream).</p>
<p>1.46 2022-01-20 Restore pre-1.44 behavior (1.44 may have broken hardware acceleration): once again use decodebin in the video pipeline; introduce new option “-avdec” to force software h264 decoding by libav h264, if needed (to prevent selection of vaapisink by autovideosink). Update llhttp to v6.0.6. UxPlay now reports itself as AppleTV3,2. Restrict connections to one client at a time (second client must now wait for first client to disconnect).</p>
<p>1.45 2022-01-10 New behavior: close video window when client requests “stop mirroring”. (A new “no close” option “-nc” is added for users who wish to retain previous behavior that does not close the video window).</p>
<p>1.44 2021-12-13 Omit hash of aeskey with ecdh_secret for an AirMyPC client; make an internal rearrangement of where this hash is done. Fully report all initial communications between client and server in -d debug mode. Replace decodebin in GStreamer video pipeline by h264-specific elements.</p>
<p>1.43 2021-12-07 Various internal changes, such as tests for successful decryption, uniform treatment of informational/debug messages, etc., updated README.</p>
<p>1.42 2021-11-20 Fix MAC detection to work with modern Linux interface naming practices, MacOS and *BSD.</p>
<p>1.41 2021-11-11 Further cleanups of multiple audio format support (internal changes, separated RAOP and GStreamer audio/video startup)</p>
<p>1.40 2021-11-09 Cleanup segfault in ALAC support, manpage location fix, show request Plists in debug mode.</p>
<p>1.39 2021-11-06 Added support for Apple Lossless (ALAC) audio streams.</p>
<p>1.38 2021-10-8 Add -as <em>audiosink</em> option to allow user to choose the GStreamer audiosink.</p>
<p>1.37 2021-09-29 Append “<span class="citation" data-cites="hostname">@hostname</span>” to AirPlay Server name, where “hostname” is the name of the server running uxplay (reworked change in 1.36).</p>
<p>1.36 2021-09-29 Implemented suggestion (by <span class="citation" data-cites="mrbesen">@mrbesen</span> and <span class="citation" data-cites="PetrusZ">@PetrusZ</span>) to use hostname of machine runing uxplay as the default server name</p>
<p>1.35.1 2021-09-28 Added the -vs 0 option for streaming audio, but not displaying video.</p>
<p>1.35 2021-09-10 now uses a GLib MainLoop, and builds on macOS (tested on Intel Mac, 10.15 ). New option -t <em>timeout</em> for relaunching server if no connections were active in previous <em>timeout</em> seconds (to renew Bonjour registration).</p>
<p>1.341 2021-09-04 fixed: render logger was not being destroyed by stop_server()</p>
<p>1.34 2021-08-27 Fixed “ZOOMFIX”: the X11 window name fix was only being made the first time the GStreamer window was created by uxplay, and not if the server was relaunched after the GStreamer window was closed, with uxplay still running. Corrected in v. 1.34</p>
<h1 id="improvements">Improvements</h1>
<ol type="1">
<li><p>Updates of the RAOP (AirPlay protocol) collection of codes maintained at https://github.com/FD-/RPiPlay.git so it is current as of 2021-08-01, adding all changes since the original release of UxPlay by antimof. This involved crypto updates, replacement of the included plist library by the system-installed version, and a change over to a library llhttp for http parsing.</p></li>
<li><p>Added -s, -o -p, -m, -r, -f, -fps, -vs, -as and -t options.</p></li>
<li><p>If “<code>cmake -DZOOMFIX=ON .</code>” is run before compiling, the mirrored window is now visible to screen-sharing applications such as Zoom. (This applies only to X11 windows produced by videosinks <code>ximagesink</code> and <code>xvimagesink</code>, which are often selected by default.) To compile with ZOOMFIX=ON, the X11 development libraries must be installed. <em>(ZOOMFIX will not be needed once the upcoming gstreamer-1.20 is available, since starting with that release, the GStreamer X11 mirror window will be natively visible for screen-sharing, but it make take some time for distributions to supply this version.)</em> Thanks to David Ventura https://github.com/DavidVentura/UxPlay for the fix and also for getting it into gstreamer-1.20. [If uxplay was compiled after cmake was run without -DZOOMFIX=ON, and your gstreamer version is older than 1.20, you can still manually make the X11 window visible to screen-sharing apps with the X11 utility xdotool, if it is installed, with: <code>xdotool selectwindow set_window --name &lt;name&gt;</code> (where <code>&lt;name&gt;</code> is your choice of name), and then select the uxplay window by clicking on it with the mouse.]</p></li>
<li><p>The AirPlay server now terminates correctly when the gstreamer display window is closed, and is relaunched with the same settings to wait for a new connection. The program uxplay terminates when Ctrl-C is typed in the terminal window. The <strong>-t <em>timeout</em></strong> option relaunches the server after <em>timeout</em> seconds of inactivity to allow new connections to be made.</p></li>
<li><p>In principle, multiple instances of uxplay can be run simultaneously using the <strong>-m</strong> (generate random MAC address) option to give each a different (“local” as opposed to “universal”) MAC address. If the <strong>-p [n]</strong> option is used, they also need separate network port choices. (However, there may be a large latency, and running two instances of uxplay simultaneously on the same computer may not be very useful; using the <strong>-fps</strong> option to force streaming framerates below 30fps could be helpful.)</p></li>
<li><p>Without the <strong>-p</strong> [n] option, uxplay makes a random dynamic assignment of network ports. This will not work if most ports are closed by a firewall. With e.g., <strong>-p 45000</strong> you should open both TCP and UDP on ports 45000, 45001, 45002. Minimum allowed port is 1024, maximum is 65535. The option “<strong>-p</strong>” with no argument uses a “legacy” set of ports TCP 7100, 7000, 7001, and UDP 7011, 6000, 6001. Finer control is also possible: “<strong>-p udp n1,n2,n3 -p tcp n4,n5,n6</strong>” sets all six ports individually.</p></li>
<li><p>The default resolution setting is 1920x1080 width x height pixels. To change this, use “<strong>-s wxh</strong>” where w and h are positive decimals with 4 or less digits. It seems that the width and height may be negotiated with the AirPlay client, so this may not be the actual screen geometry that displays.</p></li>
<li><p>The title on the GStreamer display window is now is the AirPlay server name. (This works for X11 windows created by gstreamer videosinks ximagesink, xvimagesink, but not OpenGL windows created by glimagesink.)</p></li>
<li><p>The avahi_compat “nag” warning on startup is suppressed, by placing “AVAHI_COMPAT_NOWARN=1” into the runtime environment when uxplay starts. (This uses a call to putenv() in a form that is believed to be safe against memory leaks, at least in modern Linux; if for any reason you don’t want this fix, comment out the line in CMakeLists.txt that activates it when uxplay is compiled.) On macOS, Avahi is not used.</p></li>
<li><p>UxPlay now builds on macOS.</p></li>
<li><p>The hostname of the server running uxplay is now appended to the AirPlay server name, which is now displayed as <em>name</em>@hostname, where <em>name</em> is “UxPlay”, (or whatever is set with the <strong>-n</strong> option).</p></li>
<li><p>Added support for audio-only streaming with original (non-Mirror) AirPlay protocol, with Apple Lossless (ALAC) audio.</p></li>
<li><p>Added suppport for the older AirPlay protocol used by third-party Windows-based AirPlay mirror emulators such as AirMyPC.</p></li>
<li><p>Made the video pipeline fully configurable with options -vp, -vd, -vc, for accelerated hardware support (e.g. NVIDIA).</p></li>
<li><p>Added Raspberry Pi support (accelerated hardware decoding) with -rpi option.</p></li>
<li><p>Added options to dump audio and/or video to file.</p></li>
</ol>
<h1 id="disclaimer">Disclaimer</h1>
<p>All the resources in this repository are written using only freely available information from the internet. The code and related resources are meant for educational purposes only. It is the responsibility of the user to make sure all local laws are adhered to.</p>
<p>This project makes use of a third-party GPL library for handling FairPlay. The legal status of that library is unclear. Should you be a representative of Apple and have any objections against the legality of the library and its use in this project, please contact me and I’ll take the appropriate steps.</p>
<p>Given the large number of third-party AirPlay receivers (mostly closed-source) available for purchase, it is my understanding that an open source implementation of the same functionality wouldn’t violate any of Apple’s rights either.</p>
<h1 id="uxplay-authors">UxPlay authors</h1>
<p><em>[adapted from fdraschbacher’s notes on RPiPlay antecedents]</em></p>
<p>The code in this repository accumulated from various sources over time. Here is an attempt at listing the various authors and the components they created:</p>
<p>UxPlay was initially created by <strong>antimof</strong> from RPiPlay, by replacing its Raspberry-Pi-specific video and audio rendering system with GStreamer rendering for Desktop Linux (antimof’s work on code in <code>renderers/</code> was later backported to RPiPlay). The previous authors of code included in UxPlay by inheritance from RPiPlay include:</p>
<ul>
<li><strong>EstebanKubata</strong>: Created a FairPlay library called <a href="https://github.com/EstebanKubata/playfair">PlayFair</a>. Located in the <code>lib/playfair</code> folder. License: GNU GPL</li>
<li><strong>Juho Vähä-Herttua</strong> and contributors: Created an AirPlay audio server called <a href="https://github.com/juhovh/shairplay">ShairPlay</a>, including support for Fairplay based on PlayFair. Most of the code in <code>lib/</code> originally stems from this project. License: GNU LGPLv2.1+</li>
<li><strong>dsafa22</strong>: Created an AirPlay 2 mirroring server <a href="https://github.com/dsafa22/AirplayServer">AirplayServer</a> (seems gone now), for Android based on ShairPlay. Code is preserved <a href="https://github.com/jiangban/AirplayServer">here</a>, and <a href="https://github.com/FDH2/UxPlay/wiki/AirPlay2">see here</a> for the description of the analysis of the AirPlay 2 mirror protocol that made RPiPlay possible, by the AirplayServer author. All code in <code>lib/</code> concerning mirroring is dsafa22’s work. License: GNU LGPLv2.1+</li>
<li><strong>Florian Draschbacher</strong> and contributors: adapted dsafa22’s Android project for the Raspberry Pi, with extensive cleanups, debugging and improvements. The project <a href="https://github.com/FD-/RPiPlay">RPiPlay</a> is basically a port of dsafa22’s code to the Raspberry Pi, utilizing OpenMAX and OpenSSL for better performance on the Pi. License GPL v3.</li>
</ul>
<p>Independent of UxPlay, but used by it and bundled with it:</p>
<ul>
<li><strong>Fedor Indutny</strong> (of Node.js, and formerly Joyent, Inc) and contributors: Created an http parsing library called <a href="https://github.com/nodejs/llhttp">llhttp</a>. Located at <code>lib/llhttp/</code>. License: MIT</li>
</ul>
<h2 id="notes-on-airplay-protocol-versions-by-florian-draschbacher-rpiplay-creator">Notes on AirPlay protocol versions by Florian Draschbacher, RPiPlay creator</h2>
<p>(From the https://github.com/FD-/RPiPlay.git repository.)</p>
<p>For multiple reasons, it’s very difficult to clearly define the protocol names and versions of the components that make up the AirPlay streaming system. In fact, it seems like the AirPlay version number used for marketing differs from that used in the actual implementation. In order to tidy up this whole mess a bit, I did a little research that I’d like to summarize here:</p>
<p>The very origin of the AirPlay protocol suite was launched as AirTunes sometime around 2004. It allowed to stream audio from iTunes to an AirPort Express station. Internally, the name of the protocol that was used was RAOP, or Remote Audio Output Protocol. It seems already back then, the protocol involved AES encryption. A public key was needed for encrypting the audio sent to an AirPort Express, and the private key was needed for receiving the protocol (ie used in the AirPort Express to decrypt the stream). Already in 2004, the public key was reverse-engineered, so that <a href="http://nanocr.eu/2004/08/11/reversing-airtunes/">third-party sender applications</a> were developed.</p>
<p>Some time <a href="https://weblog.rogueamoeba.com/2008/01/10/a-tour-of-airfoil-3/">around 2008</a>, the protocol was revised and named AirTunes 2. It seems the changes primarily concerned timing. By 2009, the new protocol was <a href="https://git.zx2c4.com/Airtunes2/about/">reverse-engineered and documented</a>.</p>
<p>When the Apple TV 2nd generation was introduced in 2010, it received support for the AirTunes protocol. However, because this device allowed playback of visual content, the protocol was extended and renamed AirPlay. It was now possible to stream photo slideshows and videos. Shortly after the release of the Apple TV 2nd generation, AirPlay support for iOS was included in the iOS 4.2 update. It seems like at that point, the audio stream was still actually using the same AirTunes 2 protocol as described above. The video and photo streams were added as a whole new protocol based on HTTP, pretty much independent from the audio stream. Soon, the first curious developers began to <a href="https://web.archive.org/web/20101211213705/http://www.tuaw.com/2010/12/08/dear-aunt-tuaw-can-i-airplay-to-my-mac/">investigate how it worked</a>. Their conclusion was that visual content is streamed unencrypted.</p>
<p>In April 2011, a talented hacker <a href="http://www.macrumors.com/2011/04/11/apple-airplay-private-key-exposed-opening-door-to-airport-express-emulators/">extracted the AirPlay private key</a> from an AirPort Express. This meant that finally, third-party developers were able to also build AirPlay receiver (server) programs.</p>
<p>For iOS 5, released in 2011, Apple added a new protocol to the AirPlay suite: AirPlay mirroring. <a href="https://www.aorensoftware.com/blog/2011/08/20/exploring-airplay-mirroring-internals/">Initial investigators</a> found this new protocol used encryption in order to protect the transferred video data.</p>
<p>By 2012, most of AirPlay’s protocols had been reverse-engineered and <a href="https://nto.github.io/AirPlay.html">documented</a> (see also <a href="https://openairplay.github.io/airplay-spec">updated version</a>). At this point, audio still used the AirTunes 2 protocol from around 2008, video, photos and mirroring still used their respective protocols in an unmodified form, so you could still speak of AirPlay 1 (building upon AirTunes 2). The Airplay server running on the Apple TV reported as version 130. The setup of AirPlay mirroring used the xml format, in particular a stream.xml file. Additionally, it seems like the actual audio data is using the ALAC codec for audio-only (AirTunes 2) streaming and AAC for mirror audio. At least these different formats were used in <a href="https://github.com/espes/Slave-in-the-Magic-Mirror/issues/12#issuecomment-372380451">later iOS versions</a>.</p>
<p>Sometime before iOS 9, the protocol for mirroring was slightly modified: Instead of the “stream.xml” API endpoint, the same information could also be querried in binary plist form, just by changing the API endpoint to “stream”, without any extension. I wasn’t able to figure out which of these was actually used by what specific client / server versions.</p>
<p>For iOS 9, Apple made <a href="https://9to5mac.com/2015/09/11/apple-ios-9-airplay-improvements-screen-mirroring/">considerable changes</a> to the AirPlay protocol in 2015, including audio and mirroring. Apparently, the audio protocol was only slightly modified, and a <a href="https://github.com/juhovh/shairplay/issues/43">minor change</a> restored compatibility. For mirroring, an <a href="https://github.com/juhovh/shairplay/issues/43#issuecomment-142115959">additional pairing phase</a> was added to the connection establishment procedure, consisting of pair-setup and pair-verify calls. Seemingly, these were added in order to simplify usage with devices that are connected frequently. Pair-setup is used only the first time an iOS device connects to an AirPlay receiver. The generated cryptographic binding can be used for pair-verify in later sessions. Additionally, the stream / stream.xml endpoint was replaced with the info endpoint (only available as binary plist AFAICT). As of iOS 12, the protocol introduced with iOS 9 was still supported with only slight modifications, albeit as a legacy mode. While iOS 9 used two SETUP calls (one for general connection and mirroring video, and one for audio), iOS 12 legacy mode uses 3 SETUP calls (one for general connection (timing and events), one for mirroring video, one for audio).</p>
<p>The release of tvOS 10.2 broke many third-party AirPlay sender (client) programs in 2017. The reason was that it was now mandatory to perform device verification via a pin in order to stream content to an Apple TV. The functionality had been in the protocol before, but was not mandatory. Some discussion about the new scheme can be found <a href="https://github.com/postlund/pyatv/issues/79">here</a>. A full specification of the pairing and authentication protocol was made available on <a href="https://htmlpreview.github.io/?https://github.com/philippe44/RAOP-Player/blob/master/doc/auth_protocol.html">GitHub</a>. At that point, tvOS 10.2 reported as AirTunes/320.20.</p>
<p>In tvOS 11, the reported server version was <a href="https://github.com/ejurgensen/forked-daapd/issues/377#issuecomment-309213273">increased to 350.92.4</a>.</p>
<p>iOS 11.4 added AirPlay 2 in 2018. Although extensively covered by the media, it’s not entirely clear what changes specifically Apple has made protocol-wise.</p>
<p>From captures of the traffic between an iOS device running iOS 12.2 and an AppleTV running tvOS 12.2.1, one can see that the communication on the main mirroring HTTP connection is encrypted after the initial handshake. This could theoretically be part of the new AirPlay 2 protocol. The AppleTV running tvOS 12.2.1 identifies as AirTunes/380.20.1. When connecting from the same iOS device to an AppleTV 3rd generation (reporting as AirTunes/220.68), the communication is still visible in plain. From the log messages that the iOS device produces when connected to an AppleTV 3rd generation, it becomes apparent that the iOS device is treating this plain protocol as the legacy protocol (as originally introduced with iOS 9). Further research showed that at the moment, all available third-party AirPlay mirroring receivers (servers) are using this legacy protocol, including the open source implementation of dsafa22, which is the base for RPiPlay. Given Apple considers this a legacy protocol, it can be expected to be removed entirely in the future. This means that all third-party AirPlay receivers will have to be updated to the new (fully encrypted) protocol at some point.</p>
<p>More specifically, the encryption starts after the pair-verify handshake completed, so the fp-setup handshake is already happening encrypted. Judging from the encryption scheme for AirPlay video (aka HLS Relay), likely two AES GCM 128 ciphers are used on the socket communication (one for sending, one for receiving). However, I have no idea how the keys are derived from the handshake data.</p>
